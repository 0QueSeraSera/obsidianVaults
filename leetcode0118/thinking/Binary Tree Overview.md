2 ways of thinking:
- Solve by **traverse** the entire tree?
- Solve by a **recursion** function and solves its **sub-tree**?
![[Pasted image 20230313200617.png]]
**_Always think about what to do with a single node_**

# Apply BiTree Traverse to other algorithms

The quick-sort finds a division point p first (_deal with the current node_), then followed with left side and right side *subproblem*
The merge-sort sorts with the sub-arrays first (left and right children), then merge (the current node)

![[Pasted image 20230313200750.png]]
![[Pasted image 20230313200811.png]]
![[Pasted image 20230313200917.png]]
