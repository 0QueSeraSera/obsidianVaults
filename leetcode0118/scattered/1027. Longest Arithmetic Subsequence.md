#DP #sub_array #chanlleging
对于数组问题，如果寻找*连续*子数组，可以使用*双指针法*或*滑动窗口*等方法，但是对于*非连续*子数组，最好使用*动态规划*。
[[873. Length of Longest Fibonacci Subsequence]]

【数组定义】
这道题特殊的是，我们不仅需要知道当前的遍历信息，也就是两个数字之间的差值，还需要知道历史信息，也就是曾经遍历时是否出现过差值一样的情况。对于需要知道历史信息的遍历过程，我们使用哈希表作为暂存器，达到快速检索的功能。

定义字典dp，字典的键是一个元组，里面包含两个元素，第一个是元素下标index，第二个是以index处元素结尾的等差数列的步长step，字典的值是该等差数列的长度。举个例子，对于数组[1,2,3,5,9,11,12,15]，字典{(6, 3):3}表达的含义就是以A[6]=15结尾，步长为3的等差数列的长度为3，也就是[9,12,15]。

【初始状态】
将字典dp设置为空即可，我们要在里面添加元素。

【递推公式】
dp的填充需要两重嵌套，成对的研究数组中两个位置previous，end,previous<end，它们的差值step = A[end] - A[previous]，我们就要看了，(previous, step)是否已经出现在dp中，如果是，则说明，end位置所在元素可以接在以previous结尾，以step为步长的等差数组中，则dp数组中添加状态dp[(end, step)]=dp[(previous, step)]+1，加一意思是加入了end位置处的元素，否则，说明end和previous确定了一个新的只含有两个元素的等差数组，dp[(end, step)]=2，两种情况合二为一，就是dp[(end, step)] = dp.get((previous, step), 1) + 1。

遍历过程中，需要及时的更新最终结果max_ans = max(max_ans, dp[(end, step)])，或者在最后给出max(dp.values())。
